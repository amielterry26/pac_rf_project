#include "handlers.h"
#include "logger.h"    // For log_info()
#include "nmea.h"     // NEW: NMEA parsing (header lives in include/)
#include <stdio.h>     // For printf()
#include <string.h>    // For strerror(), strncpy
#include <errno.h>     // For errno
#include <fcntl.h>     // For open()
#include <unistd.h>    // For read(), close(), usleep()
#include <termios.h>   // For UART config
#include <time.h>      // For time()

/**
 * handle_capture
 * ----------------------
 * Simulates a capture operation from the device.
 * Currently stubbed with logging and TERM output for GUI parsing.
 */
void handle_capture(int argc, char **argv) {
    // Silence unused parameter warnings for now
    (void)argc;
    (void)argv;

    log_info("Capture command received.");
    printf("LOG: Capture request received (stub)\n");
    printf("TERM: Simulated capture complete. (stub)\n");
}

/* -------------------------------------------------------------------------- */
/*                      UART helper for GPS configuration                      */
/* -------------------------------------------------------------------------- */

static int hs_set_uart_raw(int fd, int baud){
    struct termios tio;
    if (tcgetattr(fd, &tio) != 0) return -1;

    cfmakeraw(&tio);

    speed_t spd = B9600;
    switch (baud) {
        case 9600:   spd = B9600;   break;
        case 19200:  spd = B19200;  break;
        case 38400:  spd = B38400;  break;
        case 57600:  spd = B57600;  break;
        case 115200: spd = B115200; break;
        default:     spd = B9600;   break;
    }

    cfsetispeed(&tio, spd);
    cfsetospeed(&tio, spd);
    tio.c_cflag |= (CLOCAL | CREAD);

    // Non-blocking-ish: return after short timeout even if no bytes
    tio.c_cc[VMIN]  = 0;
    tio.c_cc[VTIME] = 2; // deciseconds (0.2s)

    return tcsetattr(fd, TCSANOW, &tio);
}

/* -------------------------------------------------------------------------- */
/*                                 GPS (REAL)                                 */
/* -------------------------------------------------------------------------- */

/**
 * handle_gps
 * ----------------------
 * Real UART GPS read on /dev/ttyPS1.
 * - Tries 9600 then 115200 baud
 * - Reads for ~2s non-blocking
 * - Parses minimal NMEA (GGA/RMC) to produce a clean TERM summary
 * - Emits last few raw NMEA lines as LOG for debugging
 *
 * GUI contract preserved:
 *   TERM: one-line summary
 *   LOG:  raw NMEA lines
 */
void handle_gps(int argc, char **argv) {
    (void)argc;
    (void)argv;

    const char *dev = "/dev/ttyPS1";
    const int   baud_try[2] = {9600, 115200};

    log_info("GPS command received (device=%s).", dev);

    // Open UART
    int fd = open(dev, O_RDONLY | O_NONBLOCK);
    if (fd < 0) {
        log_info("GPS open failed: dev=%s errno=%d (%s)", dev, errno, strerror(errno));
        printf("TERM: GPS ERROR — open failed (%s)\n", strerror(errno));
        return;
    }

    // Try common baud rates
    int use_baud = baud_try[0];
    int configured = 0;
    for (int i = 0; i < 2; i++) {
        if (hs_set_uart_raw(fd, baud_try[i]) == 0) {
            use_baud = baud_try[i];
            configured = 1;
            break;
        }
    }
    if (!configured) {
        log_info("GPS UART config failed for %s", dev);
        printf("TERM: GPS ERROR — UART config failed\n");
        close(fd);
        return;
    }

    // Read loop (~2s), parse, keep last few raw lines for LOG
    char rbuf[512];
    char line[256];
    size_t llen = 0;

    nmea_info_t info = {0};

    char last[5][128];
    int last_idx = 0, last_cnt = 0;

    time_t t0 = time(NULL);
    const long READ_MS = 2000;

    while ((time(NULL) - t0) * 1000 < READ_MS) {
        ssize_t n = read(fd, rbuf, sizeof(rbuf));
        if (n <= 0) {
            usleep(50 * 1000); // 50ms
            continue;
        }
        for (ssize_t i = 0; i < n; i++) {
            char c = rbuf[i];
            if (c == '\r') continue;

            if (c == '\n') {
                if (llen > 0) {
                    line[llen] = '\0';

                    // Keep last few lines for LOG
                    strncpy(last[last_idx], line, sizeof(last[0]) - 1);
                    last[last_idx][sizeof(last[0]) - 1] = '\0';
                    last_idx = (last_idx + 1) % 5;
                    if (last_cnt < 5) last_cnt++;

                    // Parse into info (best-effort)
                    nmea_parse_line(line, &info);

                    llen = 0;
                }
            } else if (llen + 1 < sizeof(line)) {
                line[llen++] = c;
            } else {
                // Line overflow; reset to keep parser stable
                llen = 0;
            }
        }
    }

    close(fd);

    // Human-friendly one-line summary for TERM
    if (info.has_fix || info.fix_quality > 0) {
        printf("TERM: GPS ok baud=%d fix=%s quality=%d sats=%d time=%s lat=%.6f lon=%.6f\n",
               use_baud, "VALID", info.fix_quality, info.sats,
               info.time_utc[0] ? info.time_utc : "unknown",
               info.lat_deg, info.lon_deg);
    } else {
        printf("TERM: GPS no-fix baud=%d quality=%d sats=%d time=%s (likely indoors)\n",
               use_baud, info.fix_quality, info.sats,
               info.time_utc[0] ? info.time_utc : "unknown");
    }

    // Raw NMEA tail for LOG
    for (int i = 0; i < last_cnt; i++) {
        int idx = (last_idx + i) % 5;
        printf("LOG: %s\n", last[idx]);
    }
}

/**
 * handle_tone_send
 * ----------------------
 * Simulates sending a tone signal to the device.
 * Confirms via log and terminal outputs.
 */
void handle_tone_send(int argc, char **argv) {
    (void)argc;
    (void)argv;

    log_info("Tone send command received.");
    printf("LOG: Tone send request received (stub)\n");
    printf("TERM: Simulated tone transmitted.\n");
}
